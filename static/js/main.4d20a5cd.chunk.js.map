{"version":3,"sources":["types/bingoTypes.ts","utils/shuffleArray.ts","utils/generateBingoState.ts","App.tsx","index.tsx"],"names":["ShapeType","BINGO_CARD_CENTER","shuffleArray","array","arrayCopy","map","x","i","length","j","Math","floor","random","centerConstIndex","indexOf","valueAtCenterOfCard","generateBingoState","phrasesShuffled","newBingoState","bingoRow","push","id","phrase","crossed","active","partOfRow","partOfColumn","partOfMainDiag","partOfSecDiag","App","useState","bingoRows","setBingoRows","message","setMessage","mainDiagonalCrossed","setMainDiagonalCrossed","secondaryDiagonalCrossed","setSecondaryDiagonalCrossed","React","useEffect","timeOutId","window","setTimeout","clearTimeout","switchCellsStyle","indices","activate","calledBy","bingoRowsCopy","forEach","indexPair","currentCell","Row","Column","MainDiagonal","SecondaryDiagonal","checkRowForScore","rowIndex","cellsInRowCrossedCount","cell","colIndex","setScoreMessage","checkForScores","cellsInColCrossedCount","row","checkColumnForScore","mainDiagCellsCrossedCount","index","checkMainDiagonalForScore","secDiagCellsCrossedCount","checkSecondaryDiagonalForScore","cellCount","rows","className","disabled","onClick","handleSwitchCrossedState","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4d20a5cd.chunk.js","sourcesContent":["interface BingoCardCell {\r\n  id: number;\r\n  phrase: string;\r\n  crossed: boolean;\r\n  active: boolean;\r\n  partOfRow: boolean;\r\n  partOfColumn: boolean;\r\n  partOfMainDiag: boolean;\r\n  partOfSecDiag: boolean;\r\n};\r\n\r\nexport enum ShapeType {\r\n  Row = 'Row',\r\n  Column = 'Column',\r\n  MainDiagonal = 'MainDiagonal',\r\n  SecondaryDiagonal = 'SecondaryDiagonal'\r\n};\r\n\r\nexport const BINGO_CARD_CENTER = 'BINGO_CARD_CENTER';\r\n\r\nexport default BingoCardCell;","import { BINGO_CARD_CENTER } from \"../types/bingoTypes\";\r\n\r\n// https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array\r\nconst shuffleArray = (array: Array<string>): Array<string> => {\r\n  // Create copy of array to prevent strange sideeffects\r\n  const arrayCopy = array.map((x: string) => x);\r\n\r\n  for (let i = arrayCopy.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [arrayCopy[i], arrayCopy[j]] = [arrayCopy[j], arrayCopy[i]];\r\n  }\r\n\r\n  // Find BING_CARD_CENTER const's current position\r\n  const centerConstIndex = arrayCopy.indexOf(BINGO_CARD_CENTER);\r\n\r\n  // Swap the current center value for the constant\r\n  const valueAtCenterOfCard = arrayCopy[12];\r\n  arrayCopy[12] = BINGO_CARD_CENTER;\r\n  arrayCopy[centerConstIndex] = valueAtCenterOfCard;\r\n\r\n  return arrayCopy;\r\n};\r\n\r\nexport default shuffleArray;\r\n","import shuffleArray from \"./shuffleArray\";\r\nimport BingoCardCell from \"../types/bingoTypes\";\r\nimport { BINGO_CARD_CENTER } from \"../types/bingoTypes\";\r\n\r\nconst generateBingoState = () => {\r\n  const phrases = [\r\n    'child noises in the background',\r\n    'Hello, hello?',\r\n    'i need to jump in another call',\r\n    'can everyone go on mute',\r\n    'could you please get closed to the mic',\r\n    '(load painful echo / feedback)',\r\n    'Next slide, please.',\r\n    'can we take this offline?',\r\n    'is ___ on the call?',\r\n    'Could you share this slides afterwards?',\r\n    'can somebody grant presenter rights?',\r\n    'can you email that to everyone?',\r\n    'sorry, i had problems loging in',\r\n    '(animal noises in the background)',\r\n    'sorry, i didn\\'n found the conference id',\r\n    'i was having connection issues',\r\n    'i\\'ll have to get back to you' ,\r\n    'who just joined?',\r\n    'sorry, something ___ with my calendar',\r\n    'do you see my screen?',\r\n    'lets wait for ___!',\r\n    'You will send the minutes?',\r\n    'sorry, i was on mute.',\r\n    'can you repeat, please?',\r\n    BINGO_CARD_CENTER\r\n  ];\r\n\r\n  const phrasesShuffled = shuffleArray(phrases);\r\n  const newBingoState: Array<Array<BingoCardCell>> = [];\r\n  let bingoRow: Array<BingoCardCell> = [];\r\n\r\n  for (let i = 0; i < phrasesShuffled.length; i++) {\r\n  \r\n    // If it's the center of the bingo card, then it should always be marked as crossed\r\n    bingoRow.push({\r\n      id: i,\r\n      phrase: phrasesShuffled[i],\r\n      crossed: phrasesShuffled[i] === BINGO_CARD_CENTER,\r\n      active: false,\r\n      partOfRow: false,\r\n      partOfColumn: false,\r\n      partOfMainDiag: false,\r\n      partOfSecDiag: false\r\n    });\r\n\r\n    if (bingoRow.length === 5) {\r\n      newBingoState.push(bingoRow);\r\n\r\n      bingoRow = [];\r\n    }\r\n  }\r\n\r\n  return newBingoState;\r\n};\r\n\r\nexport default generateBingoState;","import React, { useState } from 'react';\n\nimport './App.css';\nimport BingoCardCell, { BINGO_CARD_CENTER, ShapeType } from './types/bingoTypes';\nimport generateBingoState from './utils/generateBingoState';\n\nfunction App() {\n  const [bingoRows, setBingoRows] = useState<Array<Array<BingoCardCell>>>(generateBingoState());\n  const [message, setMessage] = useState('');\n  const [mainDiagonalCrossed, setMainDiagonalCrossed] = useState(false);\n  const [secondaryDiagonalCrossed, setSecondaryDiagonalCrossed] = useState(false);\n\n  React.useEffect(() => {\n    const timeOutId = window.setTimeout(() => {\n      setMessage('');\n    }, 2000);\n\n    return () => window.clearTimeout(timeOutId);\n  }, [message]);\n\n  const setScoreMessage = (message: string): void => {\n    setMessage(message);\n    \n    setTimeout(() => {\n      setMessage('');\n    }, 2000);\n  };\n\n  const switchCellsStyle = (indices: Array<Array<number>>, activate: boolean, calledBy: ShapeType): void => {\n    const bingoRowsCopy = bingoRows.map((x: Array<BingoCardCell>) => x);\n    \n    indices.forEach((indexPair: Array<number>) => {\n      const currentCell: BingoCardCell = bingoRowsCopy[indexPair[0]][indexPair[1]];\n\n      if (activate) {\n        currentCell.active = activate;\n        \n        switch (calledBy) {\n          case ShapeType.Row:\n            currentCell.partOfRow = true;\n            break;\n          case ShapeType.Column:\n            currentCell.partOfColumn = true;\n            break;\n          case ShapeType.MainDiagonal:\n            currentCell.partOfMainDiag = true;\n            break;\n          case ShapeType.SecondaryDiagonal:\n            currentCell.partOfSecDiag = true;\n            break;\n        }\n      } else {\n        switch (calledBy) {\n          case ShapeType.Row:\n            if (!(currentCell.partOfColumn || currentCell.partOfMainDiag || currentCell.partOfSecDiag)) {\n              currentCell.active = false;\n            }\n            break;\n          case ShapeType.Column:\n            if (!(currentCell.partOfRow || currentCell.partOfMainDiag || currentCell.partOfSecDiag)) {\n              currentCell.active = false;\n            }\n            break;\n          case ShapeType.MainDiagonal:\n            if (!(currentCell.partOfRow || currentCell.partOfColumn || currentCell.partOfSecDiag)) {\n              currentCell.active = false;\n            }\n            break;\n          case ShapeType.SecondaryDiagonal:\n            if (!(currentCell.partOfRow || currentCell.partOfColumn || currentCell.partOfMainDiag)) {\n              currentCell.active = false;\n            }\n        }\n      }\n    });\n\n    setBingoRows(bingoRowsCopy);\n  };\n  \n  const checkRowForScore = (rowIndex: number): boolean => {\n    let cellsInRowCrossedCount = 0;\n    const indices: number[][] = [];\n\n\n    bingoRows[rowIndex].forEach((cell: BingoCardCell, colIndex: number) => {\n      if (cell.crossed) {\n        cellsInRowCrossedCount++;\n      }\n\n      indices.push([rowIndex, colIndex]);\n    });\n\n    switchCellsStyle(indices, cellsInRowCrossedCount === bingoRows.length, ShapeType.Row);\n\n    if (cellsInRowCrossedCount === bingoRows.length) {\n      setScoreMessage('You\\'ve scored a row!');\n    }\n\n    return cellsInRowCrossedCount === bingoRows.length;\n  };\n\n  const checkColumnForScore = (colIndex: number): boolean => {\n    let cellsInColCrossedCount = 0;\n    const indices: number[][] = [];\n\n    bingoRows.forEach((row: Array<BingoCardCell>, rowIndex: number) => {\n      if (row[colIndex].crossed) {\n        cellsInColCrossedCount++;\n      }\n\n      indices.push([rowIndex, colIndex]);\n    });\n\n    if (cellsInColCrossedCount === bingoRows.length) {\n      setMessage('You\\'ve scored a column!');\n    }\n\n    switchCellsStyle(indices, cellsInColCrossedCount === bingoRows.length, ShapeType.Column);\n\n    return cellsInColCrossedCount === bingoRows.length;\n  };\n\n  const checkMainDiagonalForScore = (): boolean => {\n    let mainDiagCellsCrossedCount = 0;\n    const indices: number[][] = [];\n\n    bingoRows.forEach((row: Array<BingoCardCell>, index: number) => {\n      if (row[index].crossed) {\n        mainDiagCellsCrossedCount++;\n      }\n      \n      indices.push([index, index]);\n    });\n\n    if (!mainDiagonalCrossed) {\n      if (mainDiagCellsCrossedCount === bingoRows.length) {\n        setMessage('You\\'ve scored the main diagonal!');\n        setMainDiagonalCrossed(true);\n      } else {\n        setMainDiagonalCrossed(false);\n      }\n    }\n\n    switchCellsStyle(indices, mainDiagCellsCrossedCount === bingoRows.length, ShapeType.MainDiagonal);\n\n    return mainDiagCellsCrossedCount === bingoRows.length;\n  };\n\n  const checkSecondaryDiagonalForScore = (): boolean => {\n    let secDiagCellsCrossedCount = 0;\n    const indices: number[][] = [];\n\n    bingoRows.forEach((row: Array<BingoCardCell>, index: number) => {\n      if (row[(bingoRows.length - 1) - index].crossed) {\n        secDiagCellsCrossedCount++;\n      }\n\n      indices.push([index, (bingoRows.length - 1) - index]);\n    });\n\n    if (!secondaryDiagonalCrossed) {\n      if (secDiagCellsCrossedCount === bingoRows.length) {\n        setMessage('You\\'ve scored the secondary diagonal!');\n        setSecondaryDiagonalCrossed(true);\n      } else {\n        setSecondaryDiagonalCrossed(false);\n      }\n    }\n\n    switchCellsStyle(indices, secDiagCellsCrossedCount === bingoRows.length, ShapeType.SecondaryDiagonal);\n\n    return secDiagCellsCrossedCount === bingoRows.length;\n  };\n\n  const checkForScores = (rowIndex: number, colIndex: number): void => {\n    checkRowForScore(rowIndex);\n    checkColumnForScore(colIndex);\n    checkMainDiagonalForScore();\n    checkSecondaryDiagonalForScore();\n  };\n\n  const handleSwitchCrossedState = (rowIndex: number, colIndex: number): void => {\n    const bingoRowsCopy = bingoRows.map((x: Array<BingoCardCell>) => x);\n\n    bingoRowsCopy[rowIndex][colIndex].crossed = !bingoRowsCopy[rowIndex][colIndex].crossed;\n\n    setBingoRows(bingoRowsCopy);\n\n    checkForScores(rowIndex, colIndex)\n  };\n\n  let cellCount = 0;\n  const rows = bingoRows.map((row: Array<BingoCardCell>, rowIndex: number) => {\n    \n    const cells = (\n      <div id={`row-${rowIndex}`} key={`${rowIndex}-${Math.random()}`} className=\"bingo-row\">\n        {row.map((cell: BingoCardCell, colIndex: number) => {\n          if (cell.phrase !== BINGO_CARD_CENTER) {\n            cellCount++;\n          }\n\n          if (cell.phrase === BINGO_CARD_CENTER) {\n            return (\n              <button\n                id={`${rowIndex}-${colIndex}`}\n                key={`${colIndex}-${cell.id}`}\n                className={`bingo-cell ${cell.crossed ? 'cell-crossed' : ''} ${cell.active ? 'cell-active' : ''}`}\n                disabled\n              >\n                CONF CALL 😷 BINGO\n              </button>\n            );\n          }\n\n          return (\n            <button\n              id={`${rowIndex}-${colIndex}`}\n              key={`${colIndex}-${cell.id}`}\n              className={`bingo-cell ${cell.crossed ? 'cell-crossed' : ''} ${cell.active ? 'cell-active' : ''}`}\n              onClick={() => handleSwitchCrossedState(rowIndex, colIndex)}\n            >\n              <div className=\"bingo-cell-number\">\n                  {cellCount}\n              </div>\n              <div className=\"border-cell-text\">\n                {cell.phrase}\n              </div>\n            </button>);\n        })}\n      </div>\n    );\n\n    return cells;\n  });\n\n  return (\n    <>\n      <div className=\"actions-row\">\n        <button\n          onClick={() => setBingoRows(generateBingoState())}\n          className=\"action-btn\"\n        >\n          Refresh\n        </button>\n      </div>\n      {message\n      ? (\n        <div className=\"message\">\n          {message}\n        </div>\n      ) : null}\n      <div>\n        {rows}\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}